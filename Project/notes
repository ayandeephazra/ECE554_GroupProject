READ >>>>>>>>>>

Instructions are flushed only when BRANCH IS TAKEN
because Erics proc was coded based on an branch not taken assumption
Need to modify the flushing to depend on what the prediction was
Example: Need to flush whenevr the prediction is wrong
Whether that is branch taken or not taken

Need to pipe hit into EX stage
if it was a hit -- I predicted branch taken
then flowchange is just ~flowchange
  if b eq -- case 001
    bnt: flow change is normally just zero flag - if Z then flow change else dont flow change
    bt: now it would be ~Z -- if Z then dont flow change (because you already assumed this)
if it was a miss -- I predicted branch not taken
then flowchange is the same


WRITE >>>>>>>>>
IN EX stage: whenever theres a branch taken && miss in the btb need to write to btb
wwhat to write:: <<<< TAG -- PC_ID_EX[15:9] ||| valid 1 ||| strong 0 ||| target_PC -- dst_whatevr from ALU >>>
where to write:: index -> PC_ID_EX[8:0]
Ignoring S bit

cmd to generate reset.hex --  
perl -le 'print "000000\n"x512' > btb_contents_reset.hex

Problem (?)
1. case -- taken branch followed by another branch -- test3 END, REPEAT
second branch is flushed in EX stage <<<<<<< WRONG
but since it's a branch, decision is made and rewritten to btb
but it's flushed, so should i prevent that write? 
Red herring -- following branch decisions cannot be made before previous branch flow changes
(BOTH OCCUR IN EX)


STRONG BIT >>>>>>>>
whenever theres a branch decision, need to update strong bit
  if branch taken, and was hit then set strong bit
  else if (branch not taken, and was hit)
    if strong bit set
      clear strong bit
    else
      invalidate